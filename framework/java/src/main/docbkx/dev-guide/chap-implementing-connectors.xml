<?xml version="1.0" encoding="UTF-8"?>
<!--
  ~ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.
  ~
  ~ Copyright (c) 2014 ForgeRock AS. All Rights Reserved
  ~
  ~ The contents of this file are subject to the terms
  ~ of the Common Development and Distribution License
  ~ (the License). You may not use this file except in
  ~ compliance with the License.
  ~
  ~ You can obtain a copy of the License at
  ~ http://forgerock.org/license/CDDLv1.0.html
  ~ See the License for the specific language governing
  ~ permission and limitations under the License.
  ~
  ~ When distributing Covered Code, include this CDDL
  ~ Header Notice in each file and include the License file
  ~ at http://forgerock.org/license/CDDLv1.0.html
  ~ If applicable, add the following below the CDDL Header,
  ~ with the fields enclosed by brackets [] replaced by
  ~ your own identifying information:
  ~ "Portions Copyrighted [year] [name of copyright owner]"
  -->
<chapter xml:id='chap-operations'
         xmlns='http://docbook.org/ns/docbook' version='5.0' xml:lang='en'
         xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance'
         xsi:schemaLocation='http://docbook.org/ns/docbook http://docbook.org/xml/5.0/xsd/docbook.xsd'
        >
    <title>OpenICF Operations</title>

    <para>Before start developing connector you must decide which type of the connector to
        implement.
    </para>
    <section xml:id='connector-type'>
        <title>Connector Types</title>
        <para>There are two main factors needs to be decided in advance. The Connector and the
            Configuration interface.
        </para>
        <itemizedlist>
            <listitem>
                <para>Connector</para>
                <para>Every operation is executed on a new instance of the connector. The ICF
                    creates a new instanc of the Connector class and use an new or existing instance
                    of configuration to initialise the instance before the operation is executed.
                    After the execution the ICF dispose the connector instance.
                </para>
            </listitem>
            <listitem>
                <para>PoolableConnector</para>
                <para>Before the operation is exceuted an existing instance is pooled from the
                    Connector Pool or a new instance is created as it's desvribed above. After the
                    operation the Connector instance is released and placed back to to pool.
                </para>
            </listitem>
            <listitem>
                <para>Configuration</para>
                <para>Every time when the configuration is used (Validate operation or initialised a
                    new Connector instance) a new Configuration instance is created and configured
                    with the Configuration properties.
                </para>
            </listitem>
            <listitem>
                <para>StatefulConfiguration</para>
                <para>The Configuration instance is created only one and used until the Facade or
                    ConnectorPool assosiated with the Configuration is disposed.
                </para>
            </listitem>
        </itemizedlist>
        <table frame="all">
            <title>Connector Types</title>
            <tgroup cols="3">
                <colspec colname="c1" colnum="1" colwidth="1.0*"/>
                <colspec colname="c2" colnum="2" colwidth="1.0*"/>
                <colspec colname="c3" colnum="3" colwidth="1.0*"/>
                <thead>
                    <row>
                        <entry/>
                        <entry>Connector</entry>
                        <entry>PoolableConnector</entry>
                    </row>
                </thead>
                <tbody>
                    <row>
                        <entry>Configuration</entry>
                        <entry>Completely stateless combination. New Configuration and Connector
                            instance are created for every operation.
                        </entry>
                        <entry>The Connector Initialisation is an expensive operation so better to
                            keep them in a pool and new configuration is needed only when a new
                            instance is added to the pool.
                        </entry>
                    </row>
                    <row>
                        <entry>StatefulConfiguration</entry>
                        <entry>The Configuration can be used to make the heavy resource
                            inicialisation and then ligh Connector instance can execute the
                            operation.
                        </entry>
                        <entry>The Configuration has to be shared between the instances in the same
                            pool and the Connector initialisation is expensive.
                        </entry>
                    </row>
                </tbody>
            </tgroup>
        </table>
    </section>

    <section xml:id='configuration-implementation'>
        <title>Configuration Implementation</title>
        <para>ConfigurationProperty
        <itemizedlist>
            <listitem>
                <para>order</para>
                <para>Order in which this property is displayed.</para>
            </listitem>
            <listitem>
                <para>helpMessageKey</para>
                <para>Change the default help message key. (Java propertyName.help, c#
                        help_propertyName)</para>
            </listitem>
            <listitem>
                <para>displayMessageKey</para>
                <para> Change the default display message key. (Java propertyName.display, c#
                        display_propertyName)</para>
            </listitem>
            <listitem>
                <para>groupMessageKey</para>
                <para>Change the default group message key. (Java propertyName.group, c#
                        group_propertyName)</para>
            </listitem>
            <listitem>
                <para>confidential</para>
                <para>This is a confidential property whose value should be encrypted by the
                        application when persisted</para>
            </listitem>
            <listitem>
                <para>required</para>
                    <para>Property is required or not (boolean)</para>
            </listitem>
            <listitem>
                <para>operations</para>
                <para>The array of operations require this property.</para>
            </listitem>
        </itemizedlist>

        </para>
    <section xml:id='configuration-java-implementation'>
        <title>Configuration Implementation in Java</title>
        <programlisting language="java">
public class SampleConfiguration extends AbstractConfiguration  {

    /**
     * {@inheritDoc}
     */
    public void validate() {
    }

    @ConfigurationProperty(
        order = 1,
        helpMessageKey = "passwordFieldName.help",
        displayMessageKey = "passwordFieldName.display",
        groupMessageKey = "authenticateOp.group",
        confidential = false,
        required = false,
        operations = AuthenticateOp.class
    )
    public String getPasswordFieldName() {
        return passwordFieldName;
    }

    public void setPasswordFieldName(String value) {
        passwordFieldName = value;
    }
}
        </programlisting>

        <programlisting language="java">
public class SampleConfiguration extends AbstractConfiguration
    implements StatefulConfiguration {

    /**
     * {@inheritDoc}
     */
    public void release() {
    }

    /**
     * {@inheritDoc}
     */
    public void validate() {
    }
}
        </programlisting>
</section>

    <section xml:id='configuration-csharp-implementation'>
        <title>Configuration Implementation in C#</title>

        <programlisting language="csharp">
public class ActiveDirectoryConfiguration : AbstractConfiguration
    {

        [ConfigurationProperty(
            Order = 1,
            HelpMessageKey = "help_PasswordFieldName",
            DisplayMessageKey = "display_PasswordFieldName",
            GroupMessageKey = "group_PasswordFieldName",
            Confidential = false,
            Required = false,
            OperationTypes = new[] { typeof(AuthenticateOp) })
        ]
        public String PasswordFieldName
        { get; set; }

        public override void Validate()
        {
            throw new NotImplementedException();
        }
    }
        </programlisting>

        <programlisting language="csharp">
public class ActiveDirectoryConfiguration : AbstractConfiguration,
    StatefulConfiguration
    {

        public override void Validate()
        {
            throw new NotImplementedException();
        }

        public void Release()
        {
            throw new NotImplementedException();
        }
    }
        </programlisting>
</section>
    <section xml:id='configuration-properties-implementation'>
        <title>Supported Configuration Types</title>
        <para>The ICF supports limited number of configuration property types. Because the ICF has
                to serialise and deserialise these values when sending the values over the network
                this limitation has to be in place. </para>
            <para>You can use any of the following type and array of them. List or Set of them is
                not supported. The ICF  Introspect the Connfiguration class and add to configuration
                properties all property which has set/get method. If its type is not supported the
                framework throw exception. </para>
            <para>To avoid this and ignore all not supported type or just given properties you can
                use the </para>
            <programlisting language="java">
@ConfigurationClass(ignore = { "privateProperty", "internalProperty" }, skipUnsupported = true)
            </programlisting>
            <programlisting language="csharp">
[ConfigurationClass(Ignore = { "privateProperty", "internalProperty" }, SkipUnsupported = true)]
            </programlisting>
        <para>
            String.class
            long.class
            Long.class
            char.class
            Character.class
            double.class
            Double.class
            float.class
            Float.class
            int.class
            Integer.class
            boolean.class
            Boolean.class
            URI.class
            File.class
            GuardedByteArray.class
            GuardedString.class
            Script.class
        </para>
        <para>
            typeof(string),
            typeof(long),
            typeof(long?),
            typeof(char),
            typeof(char?),
            typeof(double),
            typeof(double?),
            typeof(float),
            typeof(float?),
            typeof(int),
            typeof(int?),
            typeof(bool),
            typeof(bool?),
            typeof(Uri),
            typeof(FileName),
            typeof(GuardedByteArray),
            typeof(GuardedString),
            typeof(Script)
        </para>
        </section>
    </section>

    <section xml:id='generic-exception-rules'>
        <title>Generic Rules</title>
        <para>These rules are common for all API or SPI level operations:</para>
        <section xml:id='framework-api-level-rules'>
            <title>Framework API level:</title>
            <itemizedlist>
                <listitem>
                    <para>IllegalArgumentException or NullPointerException</para>
                    <para>when ObjectClass is null or the name is blank.</para>
                </listitem>
                <listitem>
                    <para>OperationTimeoutException</para>
                    <para>when the wait timed out.ConnectorIOException, ConnectionBrokenException,</para>
                </listitem>
                <listitem>
                    <para>ConnectionFailedException</para>
                    <para>if any problem occurs with the connector server connection.</para>
                </listitem>
                <listitem>
                    <para>UnsupportedOperationException</para>
                    <para>If the Connector does not implement the required interface</para>
                </listitem>
                <listitem>
                    <para>ConnectorIOException</para>
                    <para>if failed to init remote connection because a SocketException</para>
                </listitem>
                <listitem>
                    <para>ConnectorException</para>
                    <itemizedlist>
                        <listitem>
                            <para>if failed to init remote connection and SocketException</para>
                            <para>if Unexpected request was sent to remote connector server</para>
                            <para>if Unexpected response received from remote connector server</para>
                        </listitem>
                    </itemizedlist>
                </listitem>
                <listitem>
                    <para>InvalidCredentialException</para>
                    <para>if Remote framework key is invalid</para>
                </listitem>
            </itemizedlist>

            <para>
                The pool exceptions may be interesting to IDM.
                <itemizedlist>
                    <listitem>
                        <para>ConnectorException</para>
                        <para>If the pool has no more available Connector after the {@link
                            ObjectPoolConfiguration#maxWait} time.</para>
                    </listitem>
                    <listitem>
                        <para>IllegalStateException</para>
                        <para>If Object pool already shutdown.</para>
                    </listitem>
                </itemizedlist>
            </para>
        </section>
        <section xml:id='framework-spi-level-rules'>
            <title>Connector SPI level:</title>
            <itemizedlist>
                <listitem>
                    <para>InvalidAttributeValueException</para>
                    <para>when non MULTIVALUED {@link Attribute} has multiple values. </para>
                </listitem>
                <listitem>
                    <para>IllegalArgumentException</para>
                    <para>when the value of  __PASSWORD__ or the __CURRENT_PASSWORD__ Attribute is not GuardedString.</para>
                </listitem>
                <listitem>
                    <para>IllegalStateException</para>
                    <para>when the name of {@link Attribute} is blank.</para>
                </listitem>
                <listitem>
                    <para>PermissionDeniedException</para>
                    <para> If the target resource will not allow to perform a particular operation. An instance of {@code PermissionDeniedException} generally describes a native error returned by (or wraps a native exception thrown by) the target resource.</para>
                </listitem>
                <listitem>
                    <para>ConnectorIOException, ConnectionBrokenException, ConnectionFailedException</para>
                    <para>if any problem occurs with the resource connection.</para>
                </listitem>
                <listitem>
                    <para>PreconditionFailedException</para>
                    <para>if resource objects's current version does not match the version provided.</para>
                </listitem>
                <listitem>
                    <para>PreconditionRequiredException</para>
                    <para>if a resource object requires a version, but no version was supplied in the {@link Uid#getRevision}</para>
                </listitem>
            </itemizedlist>
        </section>
    </section>

    <section xml:id='chap-authenticate'>
        <title>Authenticate Operation</title>
        <para>asd</para>
        <section xml:id='AuthenticationApiOp-api-level-rules'>
            <title>AuthenticationApiOp</title>
            <para>These rules are for API level:
                RuntimeException - if the credentials do not pass authentication otherwise nothing.
            </para>
            <programlisting language="java">@Test
public void authenticateTest() {
    logger.info("Running Authentication Test");
    final ConnectorFacade facade = createConnectorFacade(BasicConnector.class, null);
    final OperationOptionsBuilder builder = new OperationOptionsBuilder();
    Uid uid =
            facade.authenticate(ObjectClass.ACCOUNT, "username", new GuardedString("Passw0rd"
                    .toCharArray()), builder.build());
    Assert.assertEquals(uid.getUidValue(), "username");
}</programlisting>
        </section>
        <section xml:id='AuthenticateOp-spi-level-rules'>
            <title>AuthenticateOp</title>
            <programlisting language="java">public Uid authenticate(final ObjectClass objectClass, final String userName,
        final GuardedString password, final OperationOptions options) {
    if (ObjectClass.ACCOUNT.equals(objectClass)) {
        return new Uid(userName);
    } else {
        logger.warn("Authenticate of type {0} is not supported", configuration
                .getConnectorMessages().format(objectClass.getDisplayNameKey(),
                        objectClass.getObjectClassValue()));
        throw new UnsupportedOperationException("Authenticate of type"
                + objectClass.getObjectClassValue() + " is not supported");
    }
}</programlisting>

            <para>These rules are for SPI level:
                UnknownUidException - when the {@link Uid} does not exist on the resource.
                ConnectorSecurityException -
                InvalidCredentialException
                InvalidPasswordException
                PasswordExpiredException


                org.identityconnectors.framework.common.exceptions.ConnectorSecurityException
                org.identityconnectors.framework.common.exceptions.InvalidCredentialException
                org.identityconnectors.framework.common.exceptions.InvalidPasswordException
                org.identityconnectors.framework.common.exceptions.PasswordExpiredException
                org.identityconnectors.framework.common.exceptions.UnknownUidException
                org.identityconnectors.framework.common.exceptions.PermissionDeniedException
            </para>
        </section>
    </section>


    <section xml:id='chap-create'>
        <title>Create Operation</title>
        <para>asd</para>
        <section xml:id='CreateApiOp-api-level-rules'>
            <title>CreateApiOp</title>
            <programlisting language="java">@Test
public void createTest() {
    logger.info("Running Create Test");
    final ConnectorFacade facade = createConnectorFacade(BasicConnector.class, null);
    final OperationOptionsBuilder builder = new OperationOptionsBuilder();
    Set&lt;Attribute> createAttributes = new HashSet&lt;Attribute>();
    createAttributes.add(new Name("Foo"));
    createAttributes.add(AttributeBuilder.buildPassword("Password".toCharArray()));
    createAttributes.add(AttributeBuilder.buildEnabled(true));
    Uid uid = facade.create(ObjectClass.ACCOUNT, createAttributes, builder.build());
    Assert.assertEquals(uid.getUidValue(), "foo");
}</programlisting>
            <para>IllegalArgumentException - if {@code ObjectClass} is missing or elements of the set produce duplicate
                values of {@link Attribute#getName()}.
                NullPointerException - if the parameter
                <code>createAttributes</code>
                is<code>null</code>.
                RuntimeException - if the {@link Connector} SPI throws a native {@link Exception}
            </para>
        </section>
        <section xml:id='CreateOp-spi-level-rules'>
            <title>CreateOp</title>
            <programlisting language="java">public Uid create(final ObjectClass objectClass, final Set&lt;Attribute> createAttributes,
        final OperationOptions options) {
    if (ObjectClass.ACCOUNT.equals(objectClass) || ObjectClass.GROUP.equals(objectClass)) {
        Name name = AttributeUtil.getNameFromAttributes(createAttributes);
        if (name != null) {
            // do real create here
            return new Uid(AttributeUtil.getStringValue(name).toLowerCase());
        } else {
            throw new InvalidAttributeValueException("Name attribute is required");
        }
    } else {
        logger.warn("Delete of type {0} is not supported", configuration.getConnectorMessages()
                .format(objectClass.getDisplayNameKey(), objectClass.getObjectClassValue()));
        throw new UnsupportedOperationException("Delete of type"
                + objectClass.getObjectClassValue() + " is not supported");
    }
}</programlisting>
            <para>UnsupportedOperationException - if the Create operation on given ObjectClass is not supported.
                InvalidAttributeValueException - if required attribute is missing, not createable attribute is present or
                attribute has invalid value.
                AlreadyExistsException - If the object with the given Name already exits.
                PermissionDeniedException - If the target resource will not allow a Connector to perform a particular
                operation.
                ConnectorIOException, ConnectionBrokenException, ConnectionFailedException - if any problem occurs with
                the connection.
                RuntimeException - If anything goes wrong. Try to throw native exception
            </para>
        </section>
    </section>


    <section xml:id='chap-delete'>
        <title>Delete Operation</title>
        <para>asd</para>
        <section xml:id='DeleteApiOp-api-level-rules'>
            <title>DeleteApiOp</title>
            <programlisting language="java">@Test
public void deleteTest() {
    logger.info("Running Delete Test");
    final ConnectorFacade facade = createConnectorFacade(BasicConnector.class, null);
    final OperationOptionsBuilder builder = new OperationOptionsBuilder();
    facade.delete(ObjectClass.ACCOUNT, new Uid("username"), builder.build());
}</programlisting>
            <para>TODO</para>
        </section>
        <section xml:id='DeleteOp-spi-level-rules'>
            <title>DeleteOp</title>
            <programlisting language="java">public void delete(final ObjectClass objectClass, final Uid uid, final OperationOptions options) {
    if (ObjectClass.ACCOUNT.equals(objectClass) || ObjectClass.GROUP.equals(objectClass)) {
        // do real delete here
    } else {
        logger.warn("Delete of type {0} is not supported", configuration.getConnectorMessages()
                .format(objectClass.getDisplayNameKey(), objectClass.getObjectClassValue()));
        throw new UnsupportedOperationException("Delete of type"
                + objectClass.getObjectClassValue() + " is not supported");
    }
}</programlisting>
            <para>UnknownUidException - when the {@link Uid} does not exist on the resource.</para>
        </section>
    </section>


    <section xml:id='chap-resolve-username'>
        <title>Resolve Username Operation</title>
        <para>asd</para>
        <section xml:id='ResolveUsernameApiOp-api-level-rules'>
            <title>ResolveUsernameApiOp</title>
            <programlisting language="java">@Test
public void resolveUsernameTest() {
    logger.info("Running ResolveUsername Test");
    final ConnectorFacade facade = createConnectorFacade(BasicConnector.class, null);
    final OperationOptionsBuilder builder = new OperationOptionsBuilder();
    Uid uid = facade.resolveUsername(ObjectClass.ACCOUNT, "username", builder.build());
    Assert.assertEquals(uid.getUidValue(), "username");
}</programlisting>
            <para>TODO</para>
        </section>
        <section xml:id='ResolveUsernameOp-spi-level-rules'>
            <title>ResolveUsernameOp</title>
            <programlisting language="java">public Uid resolveUsername(final ObjectClass objectClass, final String userName,
        final OperationOptions options) {
    if (ObjectClass.ACCOUNT.equals(objectClass)) {
        return new Uid(userName);
    } else {
        logger.warn("ResolveUsername of type {0} is not supported", configuration
                .getConnectorMessages().format(objectClass.getDisplayNameKey(),
                        objectClass.getObjectClassValue()));
        throw new UnsupportedOperationException("ResolveUsername of type"
                + objectClass.getObjectClassValue() + " is not supported");
    }
}</programlisting>
            <para>UnknownUidException - when the {@link Uid} does not exist on the resource.</para>
        </section>
    </section>


    <section xml:id='chap-schema'>
        <title>Schema Operation</title>
        <para>asd</para>
        <section xml:id='SchemaApiOp-api-level-rules'>
            <title>SchemaApiOp</title>
            <programlisting language="java">@Test
public void schemaTest() {
    logger.info("Running Schema Test");
    final ConnectorFacade facade = createConnectorFacade(BasicConnector.class, null);
    Schema schema = facade.schema();
    Assert.assertNotNull(schema.findObjectClassInfo(ObjectClass.ACCOUNT_NAME));
}</programlisting>
            <para>TODO</para>
        </section>
        <section xml:id='SchemaOp-spi-level-rules'>
            <title>SchemaOp</title>
            <programlisting language="java">public Schema schema() {
    if (null == schema) {
        final SchemaBuilder builder = new SchemaBuilder(BasicConnector.class);
        // Account
        ObjectClassInfoBuilder accountInfoBuilder = new ObjectClassInfoBuilder();
        accountInfoBuilder.addAttributeInfo(Name.INFO);
        accountInfoBuilder.addAttributeInfo(OperationalAttributeInfos.PASSWORD);
        accountInfoBuilder.addAttributeInfo(PredefinedAttributeInfos.GROUPS);
        accountInfoBuilder.addAttributeInfo(AttributeInfoBuilder.build("firstName"));
        accountInfoBuilder.addAttributeInfo(AttributeInfoBuilder.define("lastName")
                .setRequired(true).build());
        builder.defineObjectClass(accountInfoBuilder.build());

        // Group
        ObjectClassInfoBuilder groupInfoBuilder = new ObjectClassInfoBuilder();
        groupInfoBuilder.setType(ObjectClass.GROUP_NAME);
        groupInfoBuilder.addAttributeInfo(Name.INFO);
        groupInfoBuilder.addAttributeInfo(PredefinedAttributeInfos.DESCRIPTION);
        groupInfoBuilder.addAttributeInfo(AttributeInfoBuilder.define("members").setCreatable(
                false).setUpdateable(false).setMultiValued(true).build());

        // Only the CRUD operations
        builder.defineObjectClass(groupInfoBuilder.build(), CreateOp.class, SearchOp.class,
                UpdateOp.class, DeleteOp.class);

        // Operation Options
        builder.defineOperationOption(OperationOptionInfoBuilder.buildAttributesToGet(),
                SearchOp.class);

        // Support paged Search
        builder.defineOperationOption(OperationOptionInfoBuilder.buildPageSize(),
                SearchOp.class);
        builder.defineOperationOption(OperationOptionInfoBuilder.buildPagedResultsCookie(),
                SearchOp.class);

        // Support to execute operation with provided credentials
        builder.defineOperationOption(OperationOptionInfoBuilder.buildRunWithUser());
        builder.defineOperationOption(OperationOptionInfoBuilder.buildRunWithPassword());

        schema = builder.build();
    }
    return schema;
}</programlisting>
            <para>TOdo</para>
        </section>
    </section>


    <section xml:id='chap-script-on-connector'>
        <title>Script On Connector Operation</title>
        <para>asd</para>
        <section xml:id='ScriptOnConnectorApiOp-api-level-rules'>
            <title>ScriptOnConnectorApiOp</title>
            <programlisting language="java">@Test
public void runScriptOnConnectorTest() {
    logger.info("Running RunScriptOnConnector Test");
    final ConnectorFacade facade = createConnectorFacade(BasicConnector.class, null);
    final OperationOptionsBuilder builder = new OperationOptionsBuilder();
    builder.setRunAsUser("admin");
    builder.setRunWithPassword(new GuardedString("Passw0rd".toCharArray()));

    final ScriptContextBuilder scriptBuilder =
            new ScriptContextBuilder("Groovy", "return argument");
    scriptBuilder.addScriptArgument("argument", "value");

    Object result = facade.runScriptOnConnector(scriptBuilder.build(), builder.build());
    Assert.assertEquals(result, "value");
}</programlisting>
            <para>TODO</para>
        </section>
        <section xml:id='ScriptOnConnectorOp-spi-level-rules'>
            <title>ScriptOnConnectorOp</title>
            <programlisting language="java">public Object runScriptOnConnector(ScriptContext request, OperationOptions options) {
    final ScriptExecutorFactory factory =
            ScriptExecutorFactory.newInstance(request.getScriptLanguage());
    final ScriptExecutor executor =
            factory.newScriptExecutor(getClass().getClassLoader(), request.getScriptText(),
                    true);

    if (StringUtil.isNotBlank(options.getRunAsUser())) {
        String password = SecurityUtil.decrypt(options.getRunWithPassword());
        // Use these to execute the script with these credentials
    }
    try {
        return executor.execute(request.getScriptArguments());
    } catch (Throwable e) {
        logger.warn(e, "Failed to execute Script");
        throw ConnectorException.wrap(e);
    }
}</programlisting>
            <para>TOdo</para>
        </section>
    </section>


    <section xml:id='chap-script-on-resource'>
        <title>Script On Resource Operation</title>
        <para>asd</para>
        <section xml:id='ScriptOnResourceApiOp-api-level-rules'>
            <title>ScriptOnResourceApiOp</title>
            <programlisting language="java">@Test
public void runScriptOnResourceTest() {
    logger.info("Running RunScriptOnResource Test");
    final ConnectorFacade facade = createConnectorFacade(BasicConnector.class, null);
    final OperationOptionsBuilder builder = new OperationOptionsBuilder();
    builder.setRunAsUser("admin");
    builder.setRunWithPassword(new GuardedString("Passw0rd".toCharArray()));

    final ScriptContextBuilder scriptBuilder = new ScriptContextBuilder("bash", "whoami");

    Object result = facade.runScriptOnResource(scriptBuilder.build(), builder.build());
    Assert.assertEquals(result, "admin");
}</programlisting>
            <para>TODO</para>
        </section>
        <section xml:id='ScriptOnResourceOp-spi-level-rules'>
            <title>ScriptOnResourceOp</title>
            <programlisting language="java">public Object runScriptOnResource(ScriptContext request, OperationOptions options) {
    try {
        // Execute the script on remote resource
        if (StringUtil.isNotBlank(options.getRunAsUser())) {
            String password = SecurityUtil.decrypt(options.getRunWithPassword());
            // Use these to execute the script with these credentials
            return options.getRunAsUser();
        }
        throw new UnknownHostException("Failed to connect to remote SSH");
    } catch (Throwable e) {
        logger.warn(e, "Failed to execute Script");
        throw ConnectorException.wrap(e);
    }
}</programlisting>
            <para>TODO</para>
        </section>
    </section>


    <section xml:id='chap-search'>
        <title>Search Operation</title>
        <para>asd</para>
        <section xml:id='GetApiOp-api-level-rules'>
            <title>GetApiOp</title>
            <programlisting language="java">@Test
public void getObjectTest() {
    logger.info("Running GetObject Test");
    final ConnectorFacade facade = createConnectorFacade(BasicConnector.class, null);
    final OperationOptionsBuilder builder = new OperationOptionsBuilder();
    builder.setAttributesToGet(Name.NAME);
    ConnectorObject co =
            facade.getObject(ObjectClass.ACCOUNT, new Uid(
                    "3f50eca0-f5e9-11e3-a3ac-0800200c9a66"), builder.build());
    Assert.assertEquals(co.getName().getNameValue(), "Foo");
}</programlisting>
            <para>UnknownUidException - when the {@link Uid} does not exist on the resource.</para>
        </section>
        <section xml:id='SearchApiOp-api-level-rules'>
            <title>SearchApiOp</title>
            <programlisting language="java">@Test
public void searchTest() {
    logger.info("Running Search Test");
    final ConnectorFacade facade = createConnectorFacade(BasicConnector.class, null);
    final OperationOptionsBuilder builder = new OperationOptionsBuilder();
    builder.setPageSize(10);
    final ResultsHandler handler = new ToListResultsHandler();

    SearchResult result =
            facade.search(ObjectClass.ACCOUNT, FilterBuilder.equalTo(new Name("Foo")), handler,
                    builder.build());
    Assert.assertEquals(result.getPagedResultsCookie(), "0");
    Assert.assertEquals(((ToListResultsHandler) handler).getObjects().size(), 1);
}</programlisting>
            <para>TODO</para>
        </section>
        <section xml:id='SearchOp-spi-level-rules'>
            <title>SearchOp</title>
            <programlisting language="java">public FilterTranslator&lt;String> createFilterTranslator(ObjectClass objectClass,
        OperationOptions options) {
    return new BasicFilterTranslator();
}

public void executeQuery(ObjectClass objectClass, String query, ResultsHandler handler,
        OperationOptions options) {
    final ConnectorObjectBuilder builder = new ConnectorObjectBuilder();
    builder.setUid("3f50eca0-f5e9-11e3-a3ac-0800200c9a66");
    builder.setName("Foo");
    builder.addAttribute(AttributeBuilder.buildEnabled(true));

    for (ConnectorObject connectorObject : CollectionUtil.newSet(builder.build())) {
        if (!handler.handle(connectorObject)) {
            // Stop iterating because the handler stopped processing
            break;
        }
    }
    if (options.getPageSize() != null &amp;&amp; 0 &lt; options.getPageSize()) {
        logger.info("Paged Search was requested");
        ((SearchResultsHandler) handler).handleResult(new SearchResult("0", 0));
    }
}</programlisting>
            <para>TOdo</para>
        </section>
    </section>


    <section xml:id='chap-sync'>
        <title>Sync Operation</title>
        <para>asd</para>
        <section xml:id='SyncApiOp-api-level-rules'>
            <title>SyncApiOp</title>
            <para>TODO</para>
            <programlisting language="java">@Test
public void getLatestSyncTokenTest() {
    logger.info("Running GetLatestSyncToken Test");
    final ConnectorFacade facade = createConnectorFacade(BasicConnector.class, null);
    SyncToken token = facade.getLatestSyncToken(ObjectClass.ACCOUNT);
    Assert.assertEquals(token.getValue(), 10);
}</programlisting>
            <programlisting language="java">@Test
public void syncTest() {
    logger.info("Running Sync Test");
    final ConnectorFacade facade = createConnectorFacade(BasicConnector.class, null);
    final OperationOptionsBuilder builder = new OperationOptionsBuilder();
    builder.setPageSize(10);
    final SyncResultsHandler handler = new SyncResultsHandler() {
        public boolean handle(SyncDelta delta) {
            return false;
        }
    };

    SyncToken token =
            facade.sync(ObjectClass.ACCOUNT, new SyncToken(10), handler, builder.build());
    Assert.assertEquals(token.getValue(), 10);
}</programlisting>

            <section xml:id='SyncApiOp-sync-api-level-rules'>
                <title>sync</title>
                <para>IllegalArgumentException - if {@code objectClass} or {@code handler} is null or if any argument is
                    invalid.
                </para>
            </section>
            <section xml:id='SyncApiOp-getLatestSyncToken-api-level-rules'>
                <title>getLatestSyncToken</title>
                <para>IllegalArgumentException - if {@code objectClass} is null or is invalid.</para>
            </section>
        </section>
        <section xml:id='SyncOp-spi-level-rules'>
            <title>SyncOp</title>
            <programlisting language="java">public void sync(ObjectClass objectClass, SyncToken token, SyncResultsHandler handler,
        final OperationOptions options) {
    if (ObjectClass.ALL.equals(objectClass)) {
        //
    } else if (ObjectClass.ACCOUNT.equals(objectClass)) {
        final ConnectorObjectBuilder builder = new ConnectorObjectBuilder();
        builder.setUid("3f50eca0-f5e9-11e3-a3ac-0800200c9a66");
        builder.setName("Foo");
        builder.addAttribute(AttributeBuilder.buildEnabled(true));

        final SyncDeltaBuilder deltaBuilder = new SyncDeltaBuilder();
        deltaBuilder.setObject(builder.build());
        deltaBuilder.setDeltaType(SyncDeltaType.CREATE);
        deltaBuilder.setToken(new SyncToken(10));

        for (SyncDelta connectorObject : CollectionUtil.newSet(deltaBuilder.build())) {
            if (!handler.handle(connectorObject)) {
                // Stop iterating because the handler stopped processing
                break;
            }
        }
    } else {
        logger.warn("Sync of type {0} is not supported", configuration.getConnectorMessages()
                .format(objectClass.getDisplayNameKey(), objectClass.getObjectClassValue()));
        throw new UnsupportedOperationException("Sync of type"
                + objectClass.getObjectClassValue() + " is not supported");
    }
    ((SyncTokenResultsHandler) handler).handleResult(new SyncToken(10));
}

public SyncToken getLatestSyncToken(ObjectClass objectClass) {
    if (ObjectClass.ACCOUNT.equals(objectClass)) {
        return new SyncToken(10);
    } else {
        logger.warn("Sync of type {0} is not supported", configuration.getConnectorMessages()
                .format(objectClass.getDisplayNameKey(), objectClass.getObjectClassValue()));
        throw new UnsupportedOperationException("Sync of type"
                + objectClass.getObjectClassValue() + " is not supported");
    }
}</programlisting>
            <para>TOdo</para>
        </section>
    </section>


    <section xml:id='chap-test'>
        <title>Test Operation</title>
        <para>asd</para>
        <section xml:id='TestApiOp-api-level-rules'>
            <title>TestApiOp</title>
            <programlisting language="java">@Test
public void testTest() {
    logger.info("Running Test Test");
    final ConnectorFacade facade = createConnectorFacade(BasicConnector.class, null);
    facade.test();
}</programlisting>
            <para>TODO</para>
        </section>
        <section xml:id='TestOp-spi-level-rules'>
            <title>TestOp</title>
            <programlisting language="java">public void test() {
    logger.ok("Test works well");
}</programlisting>
            <para>RuntimeException - if the configuration is not valid or the test failed. Implementations are
                encouraged to throw the most specific exception available. When no specific exception is available,
                implementations can throw {@link ConnectorException}.
            </para>
        </section>
    </section>


    <section xml:id='chap-update-attribute-values'>
        <title>Update Attribute Values Operation</title>
        <para>asd</para>
        <section xml:id='UpdateApiOp-api-level-rules'>
            <title>UpdateApiOp</title>
            <programlisting language="java">@Test
public void updateTest() {
    logger.info("Running Update Test");
    final ConnectorFacade facade = createConnectorFacade(BasicConnector.class, null);
    final OperationOptionsBuilder builder = new OperationOptionsBuilder();
    Set&lt;Attribute> updateAttributes = new HashSet&lt;Attribute>();
    updateAttributes.add(new Name("Foo"));

    Uid uid =
            facade.update(ObjectClass.ACCOUNT, new Uid("Foo"), updateAttributes, builder
                    .build());
    Assert.assertEquals(uid.getUidValue(), "foo");
}</programlisting>

            <programlisting language="java">@Test
public void addAttributeValuesTest() {
    logger.info("Running AddAttributeValues Test");
    final ConnectorFacade facade = createConnectorFacade(BasicConnector.class, null);
    final OperationOptionsBuilder builder = new OperationOptionsBuilder();
    Set&lt;Attribute> updateAttributes = new HashSet&lt;Attribute>();
    // add 'group2' to existing groups
    updateAttributes.add(AttributeBuilder.build(PredefinedAttributes.GROUPS_NAME, "group2"));

    Uid uid =
            facade.addAttributeValues(ObjectClass.ACCOUNT, new Uid("Foo"), updateAttributes,
                    builder.build());
    Assert.assertEquals(uid.getUidValue(), "foo");
}

@Test
public void removeAttributeValuesTest() {
    logger.info("Running RemoveAttributeValues Test");
    final ConnectorFacade facade = createConnectorFacade(BasicConnector.class, null);
    final OperationOptionsBuilder builder = new OperationOptionsBuilder();
    Set&lt;Attribute> updateAttributes = new HashSet&lt;Attribute>();
    // remove 'group2' from existing groups
    updateAttributes.add(AttributeBuilder.build(PredefinedAttributes.GROUPS_NAME, "group2"));

    Uid uid =
            facade.removeAttributeValues(ObjectClass.ACCOUNT, new Uid("Foo"), updateAttributes,
                    builder.build());
    Assert.assertEquals(uid.getUidValue(), "foo");
}</programlisting>
            <para>UnknownUidException - if the {@link Uid} does not exist on the resource and the connector does not
                implement the {@link UpdateAttributeValuesOp} interface.
            </para>
        </section>
        <section xml:id='UpdateAttributeValuesOp-spi-level-rules'>
            <title>UpdateOp</title>
            <programlisting language="java">public Uid update(ObjectClass objectClass, Uid uid, Set&lt;Attribute> replaceAttributes,
        OperationOptions options) {
    AttributesAccessor attributesAccessor = new AttributesAccessor(replaceAttributes);
    Name newName = attributesAccessor.getName();
    Uid uidAfterUpdate = uid;
    if (newName != null) {
        logger.info("Rename the object {0}:{1} to {2}", objectClass.getObjectClassValue(), uid
                .getUidValue(), newName.getNameValue());
        uidAfterUpdate = new Uid(newName.getNameValue().toLowerCase());
    }

    if (ObjectClass.ACCOUNT.equals(objectClass)) {

    } else if (ObjectClass.GROUP.is(objectClass.getObjectClassValue())) {
        if (attributesAccessor.hasAttribute("members")) {
            throw new InvalidAttributeValueException(
                    "Requested to update a read only attribute");
        }
    } else {
        logger.warn("Update of type {0} is not supported", configuration.getConnectorMessages()
                .format(objectClass.getDisplayNameKey(), objectClass.getObjectClassValue()));
        throw new UnsupportedOperationException("Update of type"
                + objectClass.getObjectClassValue() + " is not supported");
    }
    return uidAfterUpdate;
}</programlisting>
            <para>UnknownUidException - when the {@link Uid} does not exist on the resource.</para>
        </section>
        <section xml:id='UpdateOp-spi-level-rules'>
            <title>UpdateAttributeValuesOp</title>
            <programlisting language="java">public Uid addAttributeValues(ObjectClass objectClass, Uid uid, Set&lt;Attribute> valuesToAdd,
        OperationOptions options) {
    return uid;
}

public Uid removeAttributeValues(ObjectClass objectClass, Uid uid,
        Set&lt;Attribute> valuesToRemove, OperationOptions options) {
    return uid;
}</programlisting>
            <para>UnknownUidException - when the {@link Uid} does not exist on the resource.</para>
        </section>
    </section>


    <section xml:id='chap-validate'>
        <title>Validate Operation</title>
        <para>asd</para>
        <section xml:id='ValidateApiOp-api-level-rules'>
            <title>ValidateApiOp</title>
            <programlisting language="java">@Test
public void ValidateTest() {
    logger.info("Running Validate Test");
    final ConnectorFacade facade = createConnectorFacade(BasicConnector.class, null);
    facade.validate();
}</programlisting>
            <para>ConfigurationException - when the required Framework version is not compatible with the connector or
                the Connector does not have required attributes in MANIFEST.MF or when the ConfigurationProperties can
                not merge into the Configuration.
            </para>
        </section>
        <section xml:id='AbstractConfiguration-spi-level-rules'>
            <title>Configuration</title>
            <programlisting language="java">public void validate() {
    if (StringUtil.isBlank(host)) {
        throw new IllegalArgumentException("Host User cannot be null or empty.");
    }

    Assertions.blankCheck(remoteUser, "remoteUser");

    Assertions.nullCheck(password, "password");
}</programlisting>
            <para>RuntimeException - when the configuration is not valid.
                NullPointerException - when required configuration property is null.
                IllegalArgumentException - when required configuration property is blank.
            </para>
        </section>
    </section>


    <section xml:id='commons-exceptions'>
        <title>Common Exceptions</title>
        <para>Commonly used exceptions</para>
        <section xml:id='AlreadyExistsException-exception'>
            <title>AlreadyExistsException</title>
            <para>
            </para>
        </section>
        <section xml:id='ConfigurationException-exception'>
            <title>ConfigurationException</title>
            <para>
            </para>
        </section>
        <section xml:id='ConnectionBrokenException-exception'>
            <title>ConnectionBrokenException</title>
            <para>
            </para>
        </section>
        <section xml:id='ConnectionFailedException-exception'>
            <title>ConnectionFailedException</title>
            <para>
            </para>
        </section>
        <section xml:id='ConnectorException-exception'>
            <title>ConnectorException</title>
            <para>
            </para>
        </section>
        <section xml:id='ConnectorIOException-exception'>
            <title>ConnectorIOException</title>
            <para>
            </para>
        </section>
        <section xml:id='ConnectorSecurityException-exception'>
            <title>ConnectorSecurityException</title>
            <para>
            </para>
        </section>
        <section xml:id='InvalidAttributeValueException-exception'>
            <title>InvalidAttributeValueException</title>
            <para>
            </para>
        </section>
        <section xml:id='InvalidCredentialException-exception'>
            <title>InvalidCredentialException</title>
            <para>
            </para>
        </section>
        <section xml:id='InvalidPasswordException-exception'>
            <title>InvalidPasswordException</title>
            <para>
            </para>
        </section>
        <section xml:id='OperationTimeoutException-exception'>
            <title>OperationTimeoutException</title>
            <para>
            </para>
        </section>
        <section xml:id='PasswordExpiredException-exception'>
            <title>PasswordExpiredException</title>
            <para>
            </para>
        </section>
        <section xml:id='PermissionDeniedException-exception'>
            <title>PermissionDeniedException</title>
            <para>
            </para>
        </section>
        <section xml:id='PreconditionFailedException-exception'>
            <title>PreconditionFailedException</title>
            <para>
            </para>
        </section>
        <section xml:id='PreconditionRequiredException-exception'>
            <title>PreconditionRequiredException</title>
            <para>
            </para>
        </section>
        <section xml:id='RetryableException-exception'>
            <title>RetryableException</title>
            <para>
            </para>
        </section>
        <section xml:id='UnknownUidException-exception'>
            <title>UnknownUidException</title>
            <para>
            </para>
        </section>


        <section xml:id='NullPointerException-exception'>
            <title>NullPointerException (c# NullReferenceException)</title>
            <para>
            </para>
        </section>
        <section xml:id='UnsupportedOperationException-exception'>
            <title>UnsupportedOperationException (c# NotSupportedException)</title>
            <para>
            </para>
        </section>
        <section xml:id='IllegalStateException-exception'>
            <title>IllegalStateException (c# InvalidOperationException)</title>
            <para>
            </para>
        </section>
        <section xml:id='IllegalArgumentException-exception'>
            <title>IllegalArgumentException (c# ArgumentException)</title>
            <para>
            </para>
        </section>


    </section>

</chapter>